# 11. Переменные и их значения:

### Задание:

1). int allTime = 0;
int time = 0;
int distance = 0;
int currentDistance = 0; - .. // инициализация переменных, блок кода; allTime = -1; time = -1; distance = -1; currentDistance = -1; // применил рекомендацию по завершению работы с переменными. Данные переменные представляют собой временные значения, и значения расстояния, которые не могут быть отрицательными, и присвоил им отрицательное значение "-1".

2). int amt = 0; 
    int flag = 1; - .. // инициализация переменных, блок кода; amt = -1; flag = -1; return day; // применил рекомендацию по завершению работы с переменными. Переменная amt обозначает среднее значение из целых чисел, которое не может быть отрицательным (все числа положительные), поэтому в конце по завершении присваиваю ей значение -1, flag - переменная-флажок, принимает значение либо 0, либо 1. В конце по завершении работы с переменной присваиваю ей значение -1. Имена переменных выбраны плохо, в предыдущих заданиях я брал эти примеры для перименования в более подходящие, но я решил целенаправлено взять свой исходный код для примера, и править уже его. И сам факт наличия переменной флажка я тоже осознаю как плохой. В конце также добавил return как уже точный факт окончания работы функции.

3). int mid = N / 2; // N - параметр функции

.. // блок кода

for(int i = mid; i < Tele.length - 1; i ++) {..} // цикл, в котором первый раз используется переменная mid - 

.. // блок кода

int mid = N / 2;

for(int i = mid; i < Tele.length - 1; i ++) {..} // инициализировал функцию непосредственно перед циклом, в котором она должна использоваться

4). int f = 0;
int sum2 = 0;
int des = 0;

for (int i = 0; sum > 1; i++, sum /= 10) {
    f = (int)(sum % 10);
    if (f != 0) {
        sum2 += f * des;
        des *= 10;
    }
}
String result = String.valueOf(sum2);
return result; // пример исходного кода - int f = 0; int sum2 = 0; int des = 0; for (int i = 0; sum > 1; i++, sum /= 10) {..} 
String result = String.valueOf(sum2);
int f = -1;
int sum2 = -1;
int des = -1;
return result; // переменные проинициализированы изначально корректно, (имена плохие, но брал исходный код целенаправлено), в конце после работы со всеми переменными присвоил им некорректные для данного блока кода значения

5). int[] WordSearch = new int[massive_words.size()];

.. // блок кода

if (value == 0 && value + subs.length() == test.length()) {WordSearch[i] = 1; } 

// первое условие, где используется массив wordSearch - .. // блок кода

int[] WordSearch = new int[massive_words.size()];

if (value == 0 && value + subs.length() == test.length()) {WordSearch[i] = 1; } // инициализировал массив непосредственно перед его использованием

6). int f = 0; 

for (int i = 0; i < matrix.length; i++) { .. // тело цикла, где используется проверка значения f для построения новой матрицы } - 

int f = 0;

for (int i = 0; i < matrix.length; i++) {.. } // внутри тела цикла с помощью переменной f строится новая матрица

f = -1; // заведомо некорректное значение переменной, использовать такое корректно больше не получится

.. // блок кода-продолжение функции (после первого цикла функция не заканчивается, но переменная f далее больше не используется, поэтому на этом этапе я уже присваиваю ей неверное значение

7). int size = Line.length(); // line - параметр функции

.. // блок кода

for (int x = 0; x < size; x++) {.. } // цикл, где первый раз задействуется переменная size - 

.. // блок кода 

int size = Line.length();

for (int x = 0; x < size; x++) {..}

size = -1; // инициализировал переменную size непосредственно перед ее использованием в логическом выражении цикла, также после цикла, где далее переменная уже не используется, присвоил ей некорректное значение (длина не может быть отрицательной)

8). int sum_costs = 0;

.. // блок кода

for (int x = 0; x < size; x++) {..} // переменная sum_costs задействуется уже в теле цикла - 

.. // блок кода

int sum_costs = 0;

for (int x = 0; x < size; x++) {..}

sum_costs = -1; // инициализировал переменную sum_costs непосредственно перед ее использованием в теле цикла. После цикла переменная использоваться не будет, так что на этом этапе присвоил ей значение -1, которое является некорректным (сумма не может быть отрицательной)

9). int z = 16;
    
    .. // блок кода

    for (int x = 0; x < N; x++) {
        for (int y = 0; data[x] > 0; y++) {
            ..
        }
    } // цикл, где первый раз в теле цикла задействуется переменная z - 

    .. // блок кода

    int z = 16;

    for (int x = 0; x < N; x++) {
        for (int y = 0; data[x] > 0; y++) {
            ..
        }
    } // инициализировал переменную z непосредственно перед использованием в теле цикла 

10). int amt = 0;

        int time = 0;

        for (int x = 1; x <= L; x++) {
            .. // тело цикла, где пересчитываются значения amt и time
        }
        
        return time; // специально показал, что в конце функции я возвращаю значение time - 

        int amt = 0;

        int time = 0; 

        for (int x = 1; x <= L; x++) {
            .. // тело цикла, где пересчитываются значения amt и time
        }

        amt = -1; // переменная сама по себе определеяет среднее значение среди положительных чисел, она не может быть отрицательна по определению. По завершении работой с данной переменной (далее она использоваться не будет) присваиваю ей заведомо некорректное значение "-1"

        return time; // специально взял такой пример. В данном случае, поскольку я возвращаю значение time внутри функции, некорректное значение я присваиваю лишь переменной amt, а time оставляю корректной для вывода результата

11). int circle = track[amt][1] + track[amt][2]; // принимает только положительные значения

    while (time > circle) {..} // после этого цикла переменная circle не используется

    .. // блок кода - 

    int circle = track[amt][1] + track[amt][2];

    while (time > circle) {..} // после этого цикла переменная circle не используется 

    circle = -1;

    .. // блок кода. По завершении работы с переменной circle присваиваю ей заведомо некорреткное значение (изначально переменная принимает только положительные значения, т.к. строиться из значений массива с положительными числами

12). StringBuilder letter = new StringBuilder(s); создаю строку letter как копию строки s (параметр функции)

.. // блок кода, который изменяет содержание строки letter, оставляя нужные мне значения. Далее по ходу кода, исходя из содержимого строки letter меняются другие переменные внутри функции

return output; // булева переменная output, обозначаю ее как факт завершения функции - 

StringBuilder letter = new StringBuilder(s); 

.. // блок кода, который изменяет содержание строки letter. Сама переменная letter используется на протяжении всей функции

letter = new StringBuilder "***ERROR***";

return output; // Перед концом функции по завершении работы со строкой letter присваиваю ей значение ERROR как некорректное и ярко отражающее факт того, что строка дальше задействоваться нигде не должна

13). int [][] matrix = new int[M][N]; // где M и N - параметры функции

    .. // блок кода

    for (int x = 0; x < M; x++) {..} // внутри функции заполняется массив matrix - 

    .. // блок кода 

    int [][] matrix = new int[M][N];

    for (int x = 0; x < M; x++) {..} // внутри функции заполняется массив matrix. Вместо изначального варианта инициализировал массив matrix непосредственно перед его использованием в теле цикла

14). int k = 0; // по условию задачи число будет принимать положительные значения

    for (int i = 0; i <= N - 1; i++) {
        for (int j = 0; j <= N - 1 - i; j++) {
            k = i + j;
            C.add(maxInt(listA, j ,k));
        }
    }

    return C; // вставил весь блок, который относится к переменной k, т.к. он сам по себе небольшой, и я решил взять пример, где я явно после небольшого блока завершаю работу с переменной присваиванием ей некорректного значения. Вдруг после таких небольших локальных блоков такая рекомендация не сильно актуальна? Может получить замечание, корректировку или дополнительную рекомендацию по этому поводу. Но изначально я, разумеется, считаю, что подобную рекомендацию как пример хорошего стиля нужно применять везде, где это возможно - 

    int k = 0; 

    for (int i = 0; i <= N - 1; i++) {
    for (int j = 0; j <= N - 1 - i; j++) {
        k = i + j;
        C.add(maxInt(listA, j ,k));
    }
}

k = -1;

return C; // по завершению работы с переменной k присвоил ей некорректное значение

15). int start = Character.getNumericValue(copy.charAt(x)); // переменная x - параметр функции

    int end = 0; 

    int amt = 0;

    for (int i = x + 1; i < copy.length(); i++) {..} // в теле цикла изменяются переменные end и amt, переменая start не изменяется

    if (start + end == 10 && amt == 3) flag = 1; // flag - параметр функции

    if (start + end == 10 && amt != 3) flag = 2;

    return flag; - 

    int start = Character.getNumericValue(copy.charAt(x));

    int end = 0; 

    int amt = 0; 

    for (int i = x + 1; i < copy.length(); i++) {..}

    if (start + end == 10 && amt == 3) flag = 1;

    if (start + end == 10 && amt != 3) flag = 2;

    start = -1000;

    end = -1000;

    amt = -1000;

    return flag; // в данном примере были инициализированы три переменные - start, end и amt. В конце функции я вывожу значение переменной flag (параметр функции), при этом сама переменная flag формируется из условия, которым должны соответствовать переменные start, end и amt. После формирования конечного результата переменной flag и перед возвращением ее внутри функции я присваиваю всем трем переменным некорректные значения как факт завершения работы с ними (считать, что значения -1000 для каждой из них точно некорректные)